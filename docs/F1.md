# F1 Scheduled file‑sync

## 1 Why schedule a sync?

A scheduled scan keeps Home‑Index responsive: the server stays idle between ticks, then crawls **all files in `/files`** at predictable times, writing metadata (and search index updates) into `/home-index`. Users never press a “re‑index” button; new or changed files appear automatically after the next tick.

---

## 2 Configuring the schedule

Set **one environment variable** on the `home-index` service:

```yaml
CRON_EXPRESSION: "* * * * *"          # every minute – any valid cron is OK
```

* **5‑field** (`m h dom mon dow`) **or 6‑field** (`s m h dom mon dow`) formats are accepted.
  Include seconds if you need sub‑minute resolution—e.g. `*/10 * * * * *` (every 10 s).
* The schedule is interpreted in the container’s local time (UTC by default).
  Change the time‑zone via `TZ=America/Los_Angeles` if needed.

---

## 3 Minimal `docker-compose.yml`

```yaml
services:
  home-index:
    image: ghcr.io/nashspence/home-index:latest
    environment:
      - CRON_EXPRESSION=* * * * *          # edit to taste
      - METADATA_DIRECTORY=/home-index/metadata
    volumes:
      - ./input:/files:ro                  # project files (read‑only)
      - ./output:/home-index               # logs + metadata
    depends_on: [meilisearch]

  meilisearch:
    image: getmeili/meilisearch:latest
    environment: [MEILI_NO_ANALYTICS=true]
    volumes: [./output/meili:/meili_data]
```

---

## 4 Acceptance criteria (platform‑agnostic)

| #     | Scenario & pre‑conditions                                                                                                     | Steps (user actions → expected behaviour)                                                                                                                                                                                               |
| ----- | ----------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | **Initial run — existing files indexed**<br>Stack started with a valid cron expression and at least one file already present. | 1 Start stack → `output/files.log` created.<br>2 At **first tick after start** log contains `… start file sync`.<br>3 For each file, a directory `output/metadata/by-id/<hash>/` appears with `document.json`; file becomes searchable. |
| **2** | **New file appears mid‑run**                                                                                                  | 1 Copy a new file into `/files` between ticks.<br>2 At the **next tick** metadata and index entries for that file are created.                                                                                                          |
| **3** | **File contents change**                                                                                                      | 1 Replace bytes of an existing file (hash changes).<br>2 At next tick a **new** metadata directory (new hash) is created; old one remains untouched.                                                                                    |
| **4** | **Regular cadence honoured**                                                                                                  | 1 Let stack run for several ticks.<br>2 The interval between successive `start file sync` log lines matches the cron schedule ±1 s and **never faster**, even under light load.                                                         |
| **5** | **Long‑running sync never overlaps**                                                                                          | 1 Choose a cron expression shorter than the time a scan takes.<br>2 Observe that a second `start file sync` line does **not** appear until the previous run has logged `… completed file sync`.                                         |
| **6** | **Change schedule**                                                                                                           | 1 Stop containers.<br>2 Edit `CRON_EXPRESSION` (any valid new value).<br>3 Restart → Interval between subsequent `start file sync` lines follows the **new** schedule.                                                                  |
| **7** | **Fresh state on restart (same schedule)**                                                                                    | 1 After any successful run, stop containers.<br>2 Start them again with the **identical** cron expression → `output/` is recreated; a new `files.log` starts; first sync happens at the first tick after start‑up.                      |
| **8** | **Invalid cron expression blocks start‑up**                                                                                   | 1 Set `CRON_EXPRESSION` to an invalid string (e.g. `bad cron`).<br>2 Start stack → Home‑Index exits with non‑zero code; stderr (or Docker logs) contains “invalid cron expression”; container remains stopped.                          |

All scenarios must pass on Linux, macOS, and Windows (via WSL) without modifying this spec—only the concrete cron strings, file names, and timestamps vary per project.

---

**End of specification**
