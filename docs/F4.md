# F4 Modules enrich project files

## 1 Why use modules?

A **module** is a container that adds extra artefacts to a file—EXIF, OCR, captions, thumbnails …—under the control of **Redis queues**.

**Archive files are processed first**: when you plug in a Blu‑ray or USB disk, every configured module finishes its work on that drive before the pipeline turns to regular files.
The drive’s marker file (`<drive>-status-pending / ready`, §1.2) therefore flips within a single sync session.

### 1.1 Archive‑first queue ordering

When Home‑Index scans the tree it builds two tiers of jobs:

| Tier  | Condition on the file                                                        | In‑tier order |
| :---- | :--------------------------------------------------------------------------- | :------------ |
| **A** | `has_archive_paths =true` **and** the drive is currently **mounted**         | lexical path  |
| **B** | all other files (including archive files on drives that are not mounted yet) | lexical path  |

Tier A always drains before Tier B.
If a drive in Tier A is unplugged mid‑run, its remaining jobs pause until the drive re‑appears.

### 1.2 Drive‑level completion & marker files

For every archive drive `<drive>` Home‑Index maintains **one** adjacent marker file inside the archive root:

```
<drive>-status-pending   # at least one module still to run
<drive>-status-ready     # all modules complete
```

*Contents* Single ISO‑8601 UTC timestamp of the last sync that wrote the marker.

*Lifecycle*

1. After a module processes the **final** file on a drive, Home‑Index asks:
   “Are **all** modules in `MODULES` done for **all** files on this drive?”
2. **Yes** → write/refresh `<drive>-status-ready`.
   **No**  → write/refresh `<drive>-status-pending`.
3. Whichever file is written, the other (if present) is removed.
4. Files whose basename matches `*-status-(pending|ready)` are **never queued or processed** by any module.

### 1.3 Effect of module list / UID changes

At start‑up Home‑Index

1. Compares the configured `MODULES` list (name, uid, order) against the stored list.
2. Finds the **first change point** and re‑queues every file from that module onward.

All files on affected drives flip their marker to `‑status-pending` immediately, returning to `‑status-ready` once the new module versions finish.

### 1.4 Version tolerance

Modules **must remain forward‑compatible**: documents produced by older module versions stay searchable until the drive is remounted and re‑indexed. No module may crash because an archive has not yet been migrated.

---

## 2 Configure the pipeline

### 2.1 Declare modules (order + UID)

```yaml
MODULES: |
  - name: vision-module
    uid: "bb07dfb4-3b2e-4f26-9a37-81ba0f227391"
  - name: text-module
    uid: "a0648b3c-114d-4eb4-a4c7-70e8b5c9d888"
```

* **Order matters** – files flow top → bottom, but archive Tier A is always scheduled before Tier B.
* Each `uid` is printed by the module’s build template; copy (or script) it into `MODULES`.
* A change in name / uid / order is the **re‑queue point** (§1.3).

### 2.2 Key environment variables in every module container

| Variable                                                        | Required | Meaning                                                                                                       |
| --------------------------------------------------------------- | :------: | ------------------------------------------------------------------------------------------------------------- |
| `MODULE_NAME`                                                   |     ✔    | Must equal the `name` in `MODULES`.                                                                           |
| `MODULE_UID`                                                    |     ✔    | Must equal the `uid` in `MODULES`. The container starts **but ignores queue items whose uid differs** (§3‑2). |
| `REDIS_HOST`                                                    |     ✔    | Redis connection string.                                                                                      |
| `TIMEOUT`, `WORKER_ID`, `RESOURCE_SHARES`, `METADATA_DIRECTORY` |     ✖    | Optional controls – see module runtime docs.                                                                  |

---

## 3 Runner semantics (check → run loop)

1. **Home‑Index** enqueues `<module>:check` jobs in the archive‑first order (§1.1).
2. The module container **peeks** at the head of its queue:

   * **UID matches** → pull job, execute `check`; if `check` returns *True* execute `run`.
   * **UID differs** → log warning, leave job on queue, **sleep 10 minutes**.
3. On completion the module pushes a summary (done queue).

   * Home‑Index merges any `document` updates, updates Meilisearch, then (for archive files) re‑evaluates the drive marker (§1.2).
4. Re‑building a module with a new UID triggers a re‑queue from that module onward; affected drives flip to `‑status-pending`.

Directory layout per file:

```
output/metadata/by-id/<file‑hash>/
├── document.json            # merged document (all modules)
└── <module‑name>/           # one sub‑dir per module
    ├── content.json         # raw text / segment list (optional)
    ├── chunks.json          # auto‑chunked search docs
    ├── log.txt              # stdout / stderr from last run
    └── …                    # other artefacts the module writes
```

---

## 4 Writing a module

```python
from features.F4.home_index_module import run_server

def check(file_path, document, metadata_dir):
    """Fast, side‑effect‑free test: should run() execute?"""
    return not (metadata_dir / "chunks.json").is_file()

def run(file_path, document, metadata_dir):
    """Heavy work. Return data for Home‑Index to merge & index."""
    updated_doc = {"detected_labels": ["cat", "tree"]}
    raw_text    = "A cat is climbing a tree."
    return {"document": updated_doc, "content": raw_text}

if __name__ == "__main__":
    run_server(check, run)    # load/unload hooks optional
```

`run_server` automatically:

* polls queues,
* verifies **per‑item uid**,
* handles timeouts & retries,
* captures per‑file `log.txt`,
* rotates share‑group tokens, and
* pushes results back to Home‑Index.

### 4.1 `run` return values

| Key          | Type                | Effect                                                          |                                                                                            |
| ------------ | ------------------- | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| `"document"` | `dict`              | Merged into **`document.json`** then re‑indexed in Meilisearch. |                                                                                            |
| `"content"`  | `str`               |  `list[segment]`                                                | Written to `content.json`; Home‑Index auto‑chunks to `chunks.json` and indexes the chunks. |
| *others*     | serialisable values | Ignored by Home‑Index (artefacts may still be stored manually). |                                                                                            |

---

## 5 Acceptance criteria

|  # | Scenario                                | Steps → Expected result                                                                                                                                          |
| -: | --------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  1 | **Initial enrichment**                  | Start stack → archive drives (if mounted) process first; their markers flip `pending → ready`; all files searchable.                                             |
|  2 | **Plug‑in archive drive**               | Mount `<drive‑X>` whose files are outdated → its jobs jump to front of queue; after modules finish marker becomes `‑status-ready`.                               |
|  3 | **Remove drive mid‑run**                | Unmount during processing → remaining jobs pause; marker stays `‑status-pending`; on next mount they resume and marker flips to `‑status-ready`.                 |
|  4 | **UID / order change**                  | Change a module UID or reorder list → restart stack → files re‑queued from that module; affected drives’ markers flip `pending` and back to `ready` when done.   |
|  5 | **Status files ignored**                | Create `Foo-status-ready` inside archive root → no module attempts to process it; no artefacts created; file never appears in search.                            |
|  6 | **Non‑archive files unaffected**        | While an archive processes, add a regular file → it waits until Tier A empties, then processes normally.                                                         |
|  7 | **Legacy docs still searchable**        | Index contains docs from an old module version → search works before and after re‑queue; no crashes allowed.                                                     |
|  8 | **Run‑timeout**                         | Module exceeds `TIMEOUT` → job re‑queued; after fix, completes successfully.                                                                                     |
|  9 | **Check‑timeout**                       | `check` hangs → job re‑queued; after fix, completes successfully.                                                                                                |
| 10 | **Restart, no change**                  | Restart with unchanged `MODULES` → no jobs re‑queued; markers unchanged.                                                                                         |
| 11 | **Queue item uid mismatch**             | Leave stale items with old uid in queue → module logs warning, skips them, retries after 10 min; once Home‑Index re‑queues with correct uid, processing resumes. |
| 12 | **Wrong `MODULE_UID` env var**          | Start container whose `MODULE_UID` is not in `MODULES` → container logs fatal mis‑configuration and exits.                                                       |
| 13 | **Parallel modules & crash isolation**  | Two modules run; if one crashes the other still finishes; crash frees share token.                                                                               |
| 14 | **Share‑group rotation & multi‑groups** | Two containers share `{name: gpu}` → turns alternate; module requiring `gpu` + `licence` runs only when holding both tokens; no starvation.                      |
| 15 | **Meilisearch update propagation**      | Module returns new `document` / `content` → Home‑Index merges JSON, rebuilds chunks, Meilisearch reflects updates immediately.                                   |

All fifteen scenarios **must pass without editing this specification**—only module names, UIDs, drives and paths may vary.

---

**End of specification**
