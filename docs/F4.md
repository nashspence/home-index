# F4. “I want modules to enrich files”

## Value

Plug-in modules let you attach custom processors to every file. They can extract metadata or generate additional content (captions, OCR text, …). Modules run in parallel workers and place their results in the project’s `output` folder.

---

## Usage

Set the `MODULES` environment variable to a YAML list describing each module you want to run:

```yaml
- name: example-module
  filterable_attributes: []
  sortable_attributes: []
```

Each module container must define:

| Variable                 | Purpose                                             |
| ------------------------ | --------------------------------------------------- |
| `QUEUE_NAME`             | Base name of the module (e.g. `example-module`)     |
| `REDIS_HOST`             | Connection string for the shared Redis instance     |
| `TIMEOUT` *(optional)*   | Seconds before Home-Index retries a stalled job     |
| `WORKER_ID` *(optional)* | Unique ID when multiple containers share a resource |

To share scarce resources you may declare:

```yaml
- name: gpu
  seconds: 30
```

A reference implementation lives in `features/F4/module_template/`.

---

## Acceptance

### Scenario 1 – First launch, document is processed

| # | Home-Index **input**                                                                               | Home-Index **output**                                                                              |
| - | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| 1 | Start the stack with `MODULES='- name: example-module'` and at least one file mounted at `/files`. | `modules.log` is created. |
| 2 | *(user waits)* | `output/metadata/by-id/<file-hash>/example-module/version.json` appears containing `{"version": 1}`. |
| 3 | *(user waits)* | The document is indexed in Meilisearch. |

Lines [32-48](../features/F4/test/acceptance.py#L32-L48) exercise this scenario.
### Scenario 2 – A run-phase job times out and is retried

| # | Home-Index **input**                                                                                                          | Home-Index **output**                                                                                                                           |
| - | ----------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |

| 1 | Start the stack with a module that sometimes runs longer than the configured `TIMEOUT`. | `modules.log` shows `START timeout-module <hash>` without a matching `DONE`; no `version.json`. |
| 2 | Resolve the slowdown and restart the module container. | `version.json` appears and a second `START` followed by `DONE` is logged. |

Lines [93-145](../features/F4/test/acceptance.py#L93-L145) exercise this scenario.
### Scenario 3 – A check-phase job times out and is retried

| # | Home-Index **input**                                                                        | Home-Index **output**                                                        |
| - | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |

| 1 | Start with a module whose *check* step may hang longer than `TIMEOUT`. | `timeout-module:check` queue grows and no `version.json`. |
| 2 | Fix the check hang and restart the module container. | `version.json` appears after a new `START` and `DONE`. |

Lines [148-199](../features/F4/test/acceptance.py#L148-L199) exercise this scenario.
### Scenario 4 – Warm restart, module configuration **unchanged**


| 1 | After a successful run, stop all containers. | |
| 2 | Restart the stack with the **same** `MODULES` definition. | `modules.log` gains no new `START` or `DONE` lines and nothing under `output/metadata/by-id/` changes. |

Lines [100-107](../tests/test_f4_module_helpers.py#L100-L107) show how module state is detected.
### Scenario 5 – Warm restart, module configuration **changed**


| 1 | After Scenario 4, change the definition to, for example, `MODULES='- name: example-module\n  version: "2.0"'` and restart. | Every existing file is processed again and each directory is regenerated with the new version. |

Lines [100-107](../tests/test_f4_module_helpers.py#L100-L107) also apply here.
---

## Minimal `docker-compose.yml`

```yaml
services:
  home-index:
    image: ghcr.io/nashspence/home-index:latest
    environment:
      MODULES: |
        - name: example-module
      METADATA_DIRECTORY: /home-index/metadata
      REDIS_HOST: http://redis:6379
    volumes:
      - ./input:/files:ro
      - ./output:/home-index
    depends_on:
      - meilisearch
      - example-module
      - redis

  meilisearch:
    image: getmeili/meilisearch:latest
    environment:
      - MEILI_NO_ANALYTICS=true
    volumes:
      - ./output/meili:/meili_data
    ports:
      - "7700:7700"

  example-module:
    build:
      context: ./features/F4/module_template/
      dockerfile: Dockerfile
    environment:
      - METADATA_DIRECTORY=/home-index/metadata
      - QUEUE_NAME=example-module
      - REDIS_HOST=http://redis:6379
    volumes:
      - ./input:/files:ro
      - ./output:/home-index

  redis:
    image: redis:7
    command: redis-server --loglevel verbose
    ports:
      - "6379:6379"
```
